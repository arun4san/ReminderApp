{
  "author": {
    "name": "adrai"
  },
  "name": "eventstore",
  "version": "1.1.2",
  "contributors": [
    {
      "name": "Adriano Raiano",
      "email": "adriano@raiano.ch"
    },
    {
      "name": "Jan Muehlemann",
      "email": "jan.muehlemann@gmail.com"
    }
  ],
  "private": false,
  "repository": {
    "type": "git",
    "url": "git@github.com:adrai/node-eventstore.git"
  },
  "description": "Node-eventstore is a node.js module for multiple databases. It can be very useful as eventstore if you work with (d)ddd, cqrs, eventsourcing, commands and events, etc.",
  "keywords": [
    "cqrs",
    "eventstore",
    "ddd",
    "(d)ddd",
    "eventsourcing",
    "mongodb",
    "redis",
    "tingodb",
    "inmemory"
  ],
  "main": "./index.js",
  "directories": {
    "lib": "./lib"
  },
  "engines": {
    "node": ">=0.8.0"
  },
  "dependencies": {
    "async": "0.9.0",
    "debug": "1.0.4",
    "jsondate": "0.0.1",
    "lodash": "2.4.1",
    "node-uuid": "1.4.1",
    "tolerance": "1.0.0"
  },
  "devDependencies": {
    "cradle": ">=0.6.7",
    "expect.js": ">= 0.1.2",
    "mocha": ">= 1.0.1",
    "mongodb": ">= 0.0.1",
    "redis": ">= 0.10.1",
    "tingodb": ">= 0.0.1",
    "azure-storage": ">= 0.3.0"
  },
  "scripts": {
    "test": "mocha"
  },
  "readme": "# Introduction\n\n[![travis](https://img.shields.io/travis/adrai/node-eventstore.svg)](https://travis-ci.org/adrai/node-eventstore) [![npm](https://img.shields.io/npm/v/eventstore.svg)](https://npmjs.org/package/eventstore)\n\nThe project goal is to provide an eventstore implementation for node.js:\n\n- load and store events via EventStream object\n- event dispatching to your publisher (optional)\n- supported Dbs (inmemory, mongodb, redis, tingodb, azuretable)\n- snapshot support\n- query your events\n\n# Installation\n\n    npm install eventstore\n\n# Usage\n\n## Require the module and init the eventstore:\n\n    var eventstore = require('eventstore');\n    \n    var es = eventstore();\n\nBy default the eventstore will use an inmemory Storage.\n\n### Logging\n\nFor logging and debugging you can use [debug](https://github.com/visionmedia/debug) by [TJ Holowaychuk](https://github.com/visionmedia)\n\nsimply run your process with\n\n    DEBUG=eventstore* node app.js\n\n## Provide implementation for storage\n\nexample with mongodb:\n\n    var es = require('eventstore')({\n      type: 'mongodb',\n      host: 'localhost',                          // optional\n      port: 27017,                                // optional\n      dbName: 'eventstore',                       // optional\n      eventsCollectionName: 'events',             // optional\n      snapshotsCollectionName: 'snapshots',       // optional\n      transactionsCollectionName: 'transactions', // optional\n      timeout: 10000                              // optional\n      // username: 'technicalDbUser',                // optional\n      // password: 'secret'                          // optional\n    });\n    \nexample with redis:\n\n    var es = require('eventstore')({\n      type: 'redis',\n      host: 'localhost',                          // optional\n      port: 6379,                                 // optional\n      db: 0,                                      // optional\n      prefix: 'eventstore',                       // optional\n      eventsCollectionName: 'events',             // optional\n      snapshotsCollectionName: 'snapshots',       // optional\n      timeout: 10000                              // optional\n      // password: 'secret'                          // optional\n    });\n\nexample with tingodb:\n\n    var es = require('eventstore')({\n      type: 'tingodb',\n      dbPath: '/path/to/my/db/file',              // optional\n      eventsCollectionName: 'events',             // optional\n      snapshotsCollectionName: 'snapshots',       // optional\n      transactionsCollectionName: 'transactions', // optional\n      timeout: 10000                              // optional\n    });\n\nexample with azuretable:\n\n    var es = require('eventstore')({\n      type: 'azuretable',\n      storageAccount: 'nodeeventstore',\n      storageAccessKey: 'aXJaod96t980AbNwG9Vh6T3ewPQnvMWAn289Wft9RTv+heXQBxLsY3Z4w66CI7NN12+1HUnHM8S3sUbcI5zctg==',\n      storageTableHost: 'https://nodeeventstore.table.core.windows.net/',\n      eventsTableName: 'events',             // optional\n      snapshotsTableName: 'snapshots',       // optional\n      timeout: 10000                              // optional\n    });\n    \n\n## Built-in event publisher (optional)\n\nif defined the eventstore will try to publish AND set event do dispatched on its own...\n\n### sync interface\n\n    es.useEventPublisher(function(evt) {\n      // bus.emit('event', evt);\n    });\n\n### async interface\n\n    es.useEventPublisher(function(evt, callback) {\n      // bus.sendAndWaitForAck('event', evt, callback);\n    });\n\n\n## catch connect ad disconnect events\n\n    es.on('connect', function() {\n      console.log('storage connected');\n    });\n    \n    es.on('disconnect', function() {\n      console.log('connection to storage is gone');\n    });\n\n\n## initialize\n\n    es.init(function (err) {\n      // this callback is called when all is ready...\n    });\n    \n    // or\n    \n    ex.init(); // callback is optional\n \n\n## working with the eventstore\n\n### get the eventhistory (of an aggregate)\n\n    es.getEventStream('streamId', function(err, stream) {                    \n      var history = stream.events; // the original event will be in events[i].payload\n\n      // myAggregate.loadFromHistory(history);\n    });\n    \nor\n\n    es.getEventStream({\n      aggregateId: 'myAggregateId',\n      aggregate: 'person',          // optional\n      context: 'hr'                 // optional\n    }, function(err, stream) {                    \n      var history = stream.events; // the original event will be in events[i].payload\n\n      // myAggregate.loadFromHistory(history);\n    });\n\n'streamId' and 'aggregateId' are the same...\nIn ddd terms aggregate and context are just to be more precise in language.\nFor example you can have a 'person' aggregate in the context 'human ressources' and a 'person' aggregate in the context of 'business contracts'...\nSo you can have 2 complete different aggregate instances of 2 complete different aggregates (but perhaps with same name) in 2 complete different contexts\n\nyou can request an eventstream even by limit the query with a 'minimum revision number' and a 'maximum revision number'\n\n    var revMin = 5,\n        revMax = 8; // if you omit revMax or you define it as -1 it will retrieve until the end \n\n    es.getEventStream('streamId' || {/* query */}, revMin, revMax, function(err, stream) {                    \n      var history = stream.events; // the original event will be in events[i].payload\n\n      // myAggregate.loadFromHistory(history);\n    });\n\nstore a new event and commit it to store\n\n    es.getEventStream('streamId', function(err, stream) {                    \n      stream.addEvent({ my: 'event' });\n      stream.addEvents([{ my: 'event2' }]);\n      \n      stream.commit();\n      \n      // or\n      \n      stream.commit(function(err, stream) {\n        console.log(stream.eventsToDispatch); // this is an array containing all added events in this commit.\n      });\n    });\n\nif you defined an event publisher function the committed event will be dispatched to the provided publisher\n\n\n## working with snapshotting\n\nget snapshot and eventhistory from the snapshot point\n\n    es.getFromSnapshot('streamId', function(err, snapshot, stream) {\n      var snap = snapshot.data;\n      var history = stream.events; // events history from given snapshot\n    \n      // myAggregate.loadSnapshot(snap);\n      // myAggregate.loadFromHistory(history);\n    });\n\nor\n\n    es.getFromSnapshot({\n      aggregateId: 'myAggregateId',\n      aggregate: 'person',          // optional\n      context: 'hr'                 // optional\n    }, function(err, snapshot, stream) {\n      var snap = snapshot.data;\n      var history = stream.events; // events history from given snapshot\n    \n      // myAggregate.loadSnapshot(snap);\n      // myAggregate.loadFromHistory(history);\n    });\n\nyou can request a snapshot and an eventstream even by limit the query with a 'maximum revision number'\n\n    var revMax = 8; // if you omit revMax or you define it as -1 it will retrieve until the end \n\n    es.getFromSnapshot('streamId' || {/* query */}, revMax, function(err, stream) {                    \n      var snap = snapshot.data;\n      var history = stream.events; // events history from given snapshot\n    \n      // myAggregate.loadSnapshot(snap);\n      // myAggregate.loadFromHistory(history);\n    });\n\n\ncreate a snapshot point\n\n    es.getFromSnapshot('streamId', function(err, snapshot, stream) {\n      \n      var snap = snapshot.data;\n      var history = stream.events; // events history from given snapshot\n    \n      // myAggregate.loadSnapshot(snap);\n      // myAggregate.loadFromHistory(history);\n    \n      // create a new snapshot depending on your rules\n      if (history.length > myLimit) {\n        es.createSnapshot({\n          streamId: 'streamId',\n          data: myAggregate.getSnap(),\n          revision: stream.lastRevision,\n          version: 1 // optional\n        }, function(err) {\n          // snapshot saved\n        });\n        \n        // or\n        \n        es.createSnapshot({\n          aggregateId: 'myAggregateId',\n          aggregate: 'person',          // optional\n          context: 'hr'                 // optional\n          data: myAggregate.getSnap(),\n          revision: stream.lastRevision,\n          version: 1 // optional\n        }, function(err) {\n          // snapshot saved\n        });\n      }\n    \n      // go on: store new event and commit it\n      // stream.addEvents...\n    \n    });\n\n\n## own event dispatching (no event publisher function defined)\n    \n    es.getUndispatchedEvents(function(err, evts) {\n      \n      // all undispatched events\n      console.log(evts);\n    \n      // dispatch it and set the event as dispatched\n      \n      for (var e in evts) {\n        var evt = evts[r];\n        es.setEventToDispatched(evt, function(err) {});\n        // or\n        es.setEventToDispatched(evt.id, function(err) {});\n      }\n    \n    });\n\n\n## query your events\nfor replaying your events or for rebuilding a viewmodel or just for fun...\n\nskip, limit always optional\n\n    var skip = 0,\n        limit = 100; // if you omit limit or you define it as -1 it will retrieve until the end\n    \n    es.getEvents(skip, limit, function(err, evts) {\n      // if (events.length === amount) {\n      //   events.next(function (err, nextEvts) {}); // just call next to retrieve the next page...\n      // } else {\n      //   // finished...\n      // }\n    });\n    \n    // or\n    \n    es.getEvents('streamId', skip, limit, function(err, evts) {\n      // if (events.length === amount) {\n      //   events.next(function (err, nextEvts) {}); // just call next to retrieve the next page...\n      // } else {\n      //   // finished...\n      // }\n    });\n    \n    // or\n    \n    es.getEvents({ // free choice (all, only context, only aggregate, only aggregateId...)\n      context: 'hr',\n      aggregate: 'person',\n      aggregateId: 'uuid'\n    }, skip, limit, function(err, evts) {\n      // if (events.length === amount) {\n      //   events.next(function (err, nextEvts) {}); // just call next to retrieve the next page...\n      // } else {\n      //   // finished...\n      // }\n    });\n\nby revision\n\nrevMin, revMax always optional\n\n    var revMin = 5,\n        revMax = 8; // if you omit revMax or you define it as -1 it will retrieve until the end \n    \n    es.getEventsByRevision('streamId', revMin, revMax, function(err, evts) {});\n    \n    // or\n    \n    es.getEventsByRevision({\n      aggregateId: 'myAggregateId',\n      aggregate: 'person',          // optional\n      context: 'hr'                 // optional\n    }, revMin, revMax, function(err, evts) {});\n\n\n## obtain a new id\n\n    es.getNewId(function(err, newId) {\n      if(err) {\n        console.log('ohhh :-(');\n        return;\n      }\n\n      console.log('the new id is: ' + newId);\n    });\n\n\n# Sample Integration\n\n- [nodeCQRS](https://github.com/jamuhl/nodeCQRS) A CQRS sample integrating eventstore\n\n# Inspiration\n\n- Jonathan Oliver's [EventStore](https://github.com/joliver/EventStore) for .net.\n\n#[Release notes](https://github.com/adrai/node-eventstore/blob/master/releasenotes.md)\n\n# Database Support\nCurrently these databases are supported:\n\n1. inmemory\n2. mongodb ([node-mongodb-native](https://github.com/mongodb/node-mongodb-native))\n3. redis ([redis](https://github.com/mranney/node_redis))\n4. tingodb ([tingodb](https://github.com/sergeyksv/tingodb))\n5. azuretable ([azure-storage](https://github.com/Azure/azure-storage-node))\n\n## own db implementation\nYou can use your own db implementation by extending this...\n    \n    var Store = require('eventstore').Store,\n        util = require('util'),\n        _ = require('lodash');\n    \n    function MyDB(options) {\n      options = options || {};\n      Store.call(this, options);\n    }\n    \n    util.inherits(MyDB, Store);\n    \n    _.extend(MyDB.prototype, {\n      \n      // ...\n      \n    });\n    \n    module.exports = MyDB;\n\nand you can use it in this way\n\n    var es = require('eventstore)(Store);\n    // es.init...\n\n\n# License\n\nCopyright (c) 2014 Adriano Raiano, Jan Muehlemann\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/adrai/node-eventstore/issues"
  },
  "homepage": "https://github.com/adrai/node-eventstore",
  "_id": "eventstore@1.1.2",
  "dist": {
    "shasum": "63d368a42bfcab3a3677326c56f697c834c0a083"
  },
  "_from": "eventstore@^1.0.3",
  "_resolved": "https://registry.npmjs.org/eventstore/-/eventstore-1.1.2.tgz"
}
